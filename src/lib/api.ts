/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * CDC Backend API
 * API description
 * OpenAPI spec version: 1.0
 */
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryClient,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery } from '@tanstack/react-query';

import type {
    CreateConversationDto,
    CreatePostDto,
    CreateUserDto,
    PostDto,
    UpdateConversationDto,
    UpdatePostDto,
    UpdateUserDto,
    UserDto,
} from './schemas';

import type { BodyType, ErrorType } from './axiosInstance';
import { axiosInstance } from './axiosInstance';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const appControllerGetHello = (options?: SecondParameter<typeof axiosInstance>, signal?: AbortSignal) => {
    return axiosInstance<string>(
        {
            url: `/`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getAppControllerGetHelloQueryKey = () => {
    return [`/`] as const;
};

export const getAppControllerGetHelloQueryOptions = <
    TData = Awaited<ReturnType<typeof appControllerGetHello>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>;
    request?: SecondParameter<typeof axiosInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) =>
        appControllerGetHello(requestOptions, signal);

    return {
        queryKey,
        queryFn,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type AppControllerGetHelloQueryResult = NonNullable<Awaited<ReturnType<typeof appControllerGetHello>>>;
export type AppControllerGetHelloQueryError = ErrorType<unknown>;

export function useAppControllerGetHello<
    TData = Awaited<ReturnType<typeof appControllerGetHello>>,
    TError = ErrorType<unknown>,
>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof appControllerGetHello>>,
                    TError,
                    Awaited<ReturnType<typeof appControllerGetHello>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAppControllerGetHello<
    TData = Awaited<ReturnType<typeof appControllerGetHello>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof appControllerGetHello>>,
                    TError,
                    Awaited<ReturnType<typeof appControllerGetHello>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAppControllerGetHello<
    TData = Awaited<ReturnType<typeof appControllerGetHello>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAppControllerGetHello<
    TData = Awaited<ReturnType<typeof appControllerGetHello>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getAppControllerGetHelloQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const userControllerCreate = (
    createUserDto: BodyType<CreateUserDto>,
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<UserDto>(
        {
            url: `/user`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            data: createUserDto,
            signal,
        },
        options,
    );
};

export const getUserControllerCreateMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof userControllerCreate>>,
        TError,
        {
            data: BodyType<CreateUserDto>;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof userControllerCreate>>,
    TError,
    {
        data: BodyType<CreateUserDto>;
    },
    TContext
> => {
    const mutationKey = ['userControllerCreate'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof userControllerCreate>>,
        {
            data: BodyType<CreateUserDto>;
        }
    > = (props) => {
        const { data } = props ?? {};

        return userControllerCreate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type UserControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerCreate>>>;
export type UserControllerCreateMutationBody = BodyType<CreateUserDto>;
export type UserControllerCreateMutationError = ErrorType<unknown>;

export const useUserControllerCreate = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof userControllerCreate>>,
            TError,
            {
                data: BodyType<CreateUserDto>;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof userControllerCreate>>,
    TError,
    { data: BodyType<CreateUserDto> },
    TContext
> => {
    const mutationOptions = getUserControllerCreateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const userControllerFindAll = (options?: SecondParameter<typeof axiosInstance>, signal?: AbortSignal) => {
    return axiosInstance<UserDto[]>(
        {
            url: `/user`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getUserControllerFindAllQueryKey = () => {
    return [`/user`] as const;
};

export const getUserControllerFindAllQueryOptions = <
    TData = Awaited<ReturnType<typeof userControllerFindAll>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>>;
    request?: SecondParameter<typeof axiosInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getUserControllerFindAllQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindAll>>> = ({ signal }) =>
        userControllerFindAll(requestOptions, signal);

    return {
        queryKey,
        queryFn,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type UserControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerFindAll>>>;
export type UserControllerFindAllQueryError = ErrorType<unknown>;

export function useUserControllerFindAll<
    TData = Awaited<ReturnType<typeof userControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof userControllerFindAll>>,
                    TError,
                    Awaited<ReturnType<typeof userControllerFindAll>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindAll<
    TData = Awaited<ReturnType<typeof userControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof userControllerFindAll>>,
                    TError,
                    Awaited<ReturnType<typeof userControllerFindAll>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindAll<
    TData = Awaited<ReturnType<typeof userControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerFindAll<
    TData = Awaited<ReturnType<typeof userControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getUserControllerFindAllQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const userControllerFindOne = (
    id: string,
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<UserDto>(
        {
            url: `/user/${id}`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getUserControllerFindOneQueryKey = (id: string) => {
    return [`/user/${id}`] as const;
};

export const getUserControllerFindOneQueryOptions = <
    TData = Awaited<ReturnType<typeof userControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindOne>>> = ({ signal }) =>
        userControllerFindOne(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type UserControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerFindOne>>>;
export type UserControllerFindOneQueryError = ErrorType<unknown>;

export function useUserControllerFindOne<
    TData = Awaited<ReturnType<typeof userControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof userControllerFindOne>>,
                    TError,
                    Awaited<ReturnType<typeof userControllerFindOne>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
    TData = Awaited<ReturnType<typeof userControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof userControllerFindOne>>,
                    TError,
                    Awaited<ReturnType<typeof userControllerFindOne>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
    TData = Awaited<ReturnType<typeof userControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerFindOne<
    TData = Awaited<ReturnType<typeof userControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getUserControllerFindOneQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const userControllerUpdate = (
    id: string,
    updateUserDto: BodyType<UpdateUserDto>,
    options?: SecondParameter<typeof axiosInstance>,
) => {
    return axiosInstance<UserDto>(
        {
            url: `/user/${id}`,
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            data: updateUserDto,
        },
        options,
    );
};

export const getUserControllerUpdateMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof userControllerUpdate>>,
        TError,
        {
            id: string;
            data: BodyType<UpdateUserDto>;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    TError,
    {
        id: string;
        data: BodyType<UpdateUserDto>;
    },
    TContext
> => {
    const mutationKey = ['userControllerUpdate'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof userControllerUpdate>>,
        {
            id: string;
            data: BodyType<UpdateUserDto>;
        }
    > = (props) => {
        const { id, data } = props ?? {};

        return userControllerUpdate(id, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type UserControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdate>>>;
export type UserControllerUpdateMutationBody = BodyType<UpdateUserDto>;
export type UserControllerUpdateMutationError = ErrorType<unknown>;

export const useUserControllerUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof userControllerUpdate>>,
            TError,
            {
                id: string;
                data: BodyType<UpdateUserDto>;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    TError,
    { id: string; data: BodyType<UpdateUserDto> },
    TContext
> => {
    const mutationOptions = getUserControllerUpdateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const userControllerRemove = (id: string, options?: SecondParameter<typeof axiosInstance>) => {
    return axiosInstance<UserDto>(
        {
            url: `/user/${id}`,
            method: 'DELETE',
        },
        options,
    );
};

export const getUserControllerRemoveMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof userControllerRemove>>, TError, { id: string }, TContext>;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof userControllerRemove>>, TError, { id: string }, TContext> => {
    const mutationKey = ['userControllerRemove'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerRemove>>, { id: string }> = (props) => {
        const { id } = props ?? {};

        return userControllerRemove(id, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type UserControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerRemove>>>;

export type UserControllerRemoveMutationError = ErrorType<unknown>;

export const useUserControllerRemove = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof userControllerRemove>>,
            TError,
            { id: string },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof userControllerRemove>>, TError, { id: string }, TContext> => {
    const mutationOptions = getUserControllerRemoveMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const postControllerCreate = (
    createPostDto: BodyType<CreatePostDto>,
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<PostDto>(
        {
            url: `/post`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            data: createPostDto,
            signal,
        },
        options,
    );
};

export const getPostControllerCreateMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postControllerCreate>>,
        TError,
        {
            data: BodyType<CreatePostDto>;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof postControllerCreate>>,
    TError,
    {
        data: BodyType<CreatePostDto>;
    },
    TContext
> => {
    const mutationKey = ['postControllerCreate'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postControllerCreate>>,
        {
            data: BodyType<CreatePostDto>;
        }
    > = (props) => {
        const { data } = props ?? {};

        return postControllerCreate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PostControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof postControllerCreate>>>;
export type PostControllerCreateMutationBody = BodyType<CreatePostDto>;
export type PostControllerCreateMutationError = ErrorType<unknown>;

export const usePostControllerCreate = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof postControllerCreate>>,
            TError,
            {
                data: BodyType<CreatePostDto>;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof postControllerCreate>>,
    TError,
    { data: BodyType<CreatePostDto> },
    TContext
> => {
    const mutationOptions = getPostControllerCreateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const postControllerFindAll = (options?: SecondParameter<typeof axiosInstance>, signal?: AbortSignal) => {
    return axiosInstance<PostDto[]>(
        {
            url: `/post`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getPostControllerFindAllQueryKey = () => {
    return [`/post`] as const;
};

export const getPostControllerFindAllQueryOptions = <
    TData = Awaited<ReturnType<typeof postControllerFindAll>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindAll>>, TError, TData>>;
    request?: SecondParameter<typeof axiosInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getPostControllerFindAllQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postControllerFindAll>>> = ({ signal }) =>
        postControllerFindAll(requestOptions, signal);

    return {
        queryKey,
        queryFn,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof postControllerFindAll>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type PostControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof postControllerFindAll>>>;
export type PostControllerFindAllQueryError = ErrorType<unknown>;

export function usePostControllerFindAll<
    TData = Awaited<ReturnType<typeof postControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindAll>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof postControllerFindAll>>,
                    TError,
                    Awaited<ReturnType<typeof postControllerFindAll>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePostControllerFindAll<
    TData = Awaited<ReturnType<typeof postControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindAll>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof postControllerFindAll>>,
                    TError,
                    Awaited<ReturnType<typeof postControllerFindAll>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePostControllerFindAll<
    TData = Awaited<ReturnType<typeof postControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindAll>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function usePostControllerFindAll<
    TData = Awaited<ReturnType<typeof postControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindAll>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getPostControllerFindAllQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const postControllerFindOne = (
    id: string,
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<PostDto>(
        {
            url: `/post/${id}`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getPostControllerFindOneQueryKey = (id: string) => {
    return [`/post/${id}`] as const;
};

export const getPostControllerFindOneQueryOptions = <
    TData = Awaited<ReturnType<typeof postControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getPostControllerFindOneQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof postControllerFindOne>>> = ({ signal }) =>
        postControllerFindOne(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof postControllerFindOne>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type PostControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof postControllerFindOne>>>;
export type PostControllerFindOneQueryError = ErrorType<unknown>;

export function usePostControllerFindOne<
    TData = Awaited<ReturnType<typeof postControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindOne>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof postControllerFindOne>>,
                    TError,
                    Awaited<ReturnType<typeof postControllerFindOne>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePostControllerFindOne<
    TData = Awaited<ReturnType<typeof postControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindOne>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof postControllerFindOne>>,
                    TError,
                    Awaited<ReturnType<typeof postControllerFindOne>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePostControllerFindOne<
    TData = Awaited<ReturnType<typeof postControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function usePostControllerFindOne<
    TData = Awaited<ReturnType<typeof postControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof postControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getPostControllerFindOneQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const postControllerUpdate = (
    id: string,
    updatePostDto: BodyType<UpdatePostDto>,
    options?: SecondParameter<typeof axiosInstance>,
) => {
    return axiosInstance<PostDto>(
        {
            url: `/post/${id}`,
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            data: updatePostDto,
        },
        options,
    );
};

export const getPostControllerUpdateMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof postControllerUpdate>>,
        TError,
        {
            id: string;
            data: BodyType<UpdatePostDto>;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof postControllerUpdate>>,
    TError,
    {
        id: string;
        data: BodyType<UpdatePostDto>;
    },
    TContext
> => {
    const mutationKey = ['postControllerUpdate'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof postControllerUpdate>>,
        {
            id: string;
            data: BodyType<UpdatePostDto>;
        }
    > = (props) => {
        const { id, data } = props ?? {};

        return postControllerUpdate(id, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PostControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof postControllerUpdate>>>;
export type PostControllerUpdateMutationBody = BodyType<UpdatePostDto>;
export type PostControllerUpdateMutationError = ErrorType<unknown>;

export const usePostControllerUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof postControllerUpdate>>,
            TError,
            {
                id: string;
                data: BodyType<UpdatePostDto>;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof postControllerUpdate>>,
    TError,
    { id: string; data: BodyType<UpdatePostDto> },
    TContext
> => {
    const mutationOptions = getPostControllerUpdateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const postControllerRemove = (id: string, options?: SecondParameter<typeof axiosInstance>) => {
    return axiosInstance<PostDto>(
        {
            url: `/post/${id}`,
            method: 'DELETE',
        },
        options,
    );
};

export const getPostControllerRemoveMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postControllerRemove>>, TError, { id: string }, TContext>;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof postControllerRemove>>, TError, { id: string }, TContext> => {
    const mutationKey = ['postControllerRemove'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postControllerRemove>>, { id: string }> = (props) => {
        const { id } = props ?? {};

        return postControllerRemove(id, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type PostControllerRemoveMutationResult = NonNullable<Awaited<ReturnType<typeof postControllerRemove>>>;

export type PostControllerRemoveMutationError = ErrorType<unknown>;

export const usePostControllerRemove = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof postControllerRemove>>,
            TError,
            { id: string },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof postControllerRemove>>, TError, { id: string }, TContext> => {
    const mutationOptions = getPostControllerRemoveMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const conversationControllerCreate = (
    createConversationDto: BodyType<CreateConversationDto>,
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<string>(
        {
            url: `/conversation`,
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            data: createConversationDto,
            signal,
        },
        options,
    );
};

export const getConversationControllerCreateMutationOptions = <
    TError = ErrorType<unknown>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof conversationControllerCreate>>,
        TError,
        {
            data: BodyType<CreateConversationDto>;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof conversationControllerCreate>>,
    TError,
    {
        data: BodyType<CreateConversationDto>;
    },
    TContext
> => {
    const mutationKey = ['conversationControllerCreate'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof conversationControllerCreate>>,
        {
            data: BodyType<CreateConversationDto>;
        }
    > = (props) => {
        const { data } = props ?? {};

        return conversationControllerCreate(data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ConversationControllerCreateMutationResult = NonNullable<
    Awaited<ReturnType<typeof conversationControllerCreate>>
>;
export type ConversationControllerCreateMutationBody = BodyType<CreateConversationDto>;
export type ConversationControllerCreateMutationError = ErrorType<unknown>;

export const useConversationControllerCreate = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof conversationControllerCreate>>,
            TError,
            {
                data: BodyType<CreateConversationDto>;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof conversationControllerCreate>>,
    TError,
    { data: BodyType<CreateConversationDto> },
    TContext
> => {
    const mutationOptions = getConversationControllerCreateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const conversationControllerFindAll = (
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<string>(
        {
            url: `/conversation`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getConversationControllerFindAllQueryKey = () => {
    return [`/conversation`] as const;
};

export const getConversationControllerFindAllQueryOptions = <
    TData = Awaited<ReturnType<typeof conversationControllerFindAll>>,
    TError = ErrorType<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindAll>>, TError, TData>>;
    request?: SecondParameter<typeof axiosInstance>;
}) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getConversationControllerFindAllQueryKey();

    const queryFn: QueryFunction<Awaited<ReturnType<typeof conversationControllerFindAll>>> = ({ signal }) =>
        conversationControllerFindAll(requestOptions, signal);

    return {
        queryKey,
        queryFn,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindAll>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type ConversationControllerFindAllQueryResult = NonNullable<
    Awaited<ReturnType<typeof conversationControllerFindAll>>
>;
export type ConversationControllerFindAllQueryError = ErrorType<unknown>;

export function useConversationControllerFindAll<
    TData = Awaited<ReturnType<typeof conversationControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindAll>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof conversationControllerFindAll>>,
                    TError,
                    Awaited<ReturnType<typeof conversationControllerFindAll>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerFindAll<
    TData = Awaited<ReturnType<typeof conversationControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindAll>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof conversationControllerFindAll>>,
                    TError,
                    Awaited<ReturnType<typeof conversationControllerFindAll>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerFindAll<
    TData = Awaited<ReturnType<typeof conversationControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindAll>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useConversationControllerFindAll<
    TData = Awaited<ReturnType<typeof conversationControllerFindAll>>,
    TError = ErrorType<unknown>,
>(
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindAll>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getConversationControllerFindAllQueryOptions(options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const conversationControllerFindOne = (
    id: string,
    options?: SecondParameter<typeof axiosInstance>,
    signal?: AbortSignal,
) => {
    return axiosInstance<string>(
        {
            url: `/conversation/${id}`,
            method: 'GET',
            signal,
        },
        options,
    );
};

export const getConversationControllerFindOneQueryKey = (id: string) => {
    return [`/conversation/${id}`] as const;
};

export const getConversationControllerFindOneQueryOptions = <
    TData = Awaited<ReturnType<typeof conversationControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey = queryOptions?.queryKey ?? getConversationControllerFindOneQueryKey(id);

    const queryFn: QueryFunction<Awaited<ReturnType<typeof conversationControllerFindOne>>> = ({ signal }) =>
        conversationControllerFindOne(id, requestOptions, signal);

    return {
        queryKey,
        queryFn,
        enabled: !!id,
        ...queryOptions,
    } as UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindOne>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };
};

export type ConversationControllerFindOneQueryResult = NonNullable<
    Awaited<ReturnType<typeof conversationControllerFindOne>>
>;
export type ConversationControllerFindOneQueryError = ErrorType<unknown>;

export function useConversationControllerFindOne<
    TData = Awaited<ReturnType<typeof conversationControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindOne>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof conversationControllerFindOne>>,
                    TError,
                    Awaited<ReturnType<typeof conversationControllerFindOne>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerFindOne<
    TData = Awaited<ReturnType<typeof conversationControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindOne>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof conversationControllerFindOne>>,
                    TError,
                    Awaited<ReturnType<typeof conversationControllerFindOne>>
                >,
                'initialData'
            >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerFindOne<
    TData = Awaited<ReturnType<typeof conversationControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useConversationControllerFindOne<
    TData = Awaited<ReturnType<typeof conversationControllerFindOne>>,
    TError = ErrorType<unknown>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof conversationControllerFindOne>>, TError, TData>>;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getConversationControllerFindOneQueryOptions(id, options);

    const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>;
    };

    query.queryKey = queryOptions.queryKey;

    return query;
}

export const conversationControllerUpdate = (
    id: string,
    updateConversationDto: BodyType<UpdateConversationDto>,
    options?: SecondParameter<typeof axiosInstance>,
) => {
    return axiosInstance<string>(
        {
            url: `/conversation/${id}`,
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            data: updateConversationDto,
        },
        options,
    );
};

export const getConversationControllerUpdateMutationOptions = <
    TError = ErrorType<unknown>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof conversationControllerUpdate>>,
        TError,
        {
            id: string;
            data: BodyType<UpdateConversationDto>;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
    Awaited<ReturnType<typeof conversationControllerUpdate>>,
    TError,
    {
        id: string;
        data: BodyType<UpdateConversationDto>;
    },
    TContext
> => {
    const mutationKey = ['conversationControllerUpdate'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof conversationControllerUpdate>>,
        {
            id: string;
            data: BodyType<UpdateConversationDto>;
        }
    > = (props) => {
        const { id, data } = props ?? {};

        return conversationControllerUpdate(id, data, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ConversationControllerUpdateMutationResult = NonNullable<
    Awaited<ReturnType<typeof conversationControllerUpdate>>
>;
export type ConversationControllerUpdateMutationBody = BodyType<UpdateConversationDto>;
export type ConversationControllerUpdateMutationError = ErrorType<unknown>;

export const useConversationControllerUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof conversationControllerUpdate>>,
            TError,
            {
                id: string;
                data: BodyType<UpdateConversationDto>;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<
    Awaited<ReturnType<typeof conversationControllerUpdate>>,
    TError,
    { id: string; data: BodyType<UpdateConversationDto> },
    TContext
> => {
    const mutationOptions = getConversationControllerUpdateMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};

export const conversationControllerRemove = (id: string, options?: SecondParameter<typeof axiosInstance>) => {
    return axiosInstance<string>(
        {
            url: `/conversation/${id}`,
            method: 'DELETE',
        },
        options,
    );
};

export const getConversationControllerRemoveMutationOptions = <
    TError = ErrorType<unknown>,
    TContext = unknown,
>(options?: {
    mutation?: UseMutationOptions<
        Awaited<ReturnType<typeof conversationControllerRemove>>,
        TError,
        {
            id: string;
        },
        TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof conversationControllerRemove>>, TError, { id: string }, TContext> => {
    const mutationKey = ['conversationControllerRemove'];
    const { mutation: mutationOptions, request: requestOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
        Awaited<ReturnType<typeof conversationControllerRemove>>,
        {
            id: string;
        }
    > = (props) => {
        const { id } = props ?? {};

        return conversationControllerRemove(id, requestOptions);
    };

    return { mutationFn, ...mutationOptions };
};

export type ConversationControllerRemoveMutationResult = NonNullable<
    Awaited<ReturnType<typeof conversationControllerRemove>>
>;

export type ConversationControllerRemoveMutationError = ErrorType<unknown>;

export const useConversationControllerRemove = <TError = ErrorType<unknown>, TContext = unknown>(
    options?: {
        mutation?: UseMutationOptions<
            Awaited<ReturnType<typeof conversationControllerRemove>>,
            TError,
            {
                id: string;
            },
            TContext
        >;
        request?: SecondParameter<typeof axiosInstance>;
    },
    queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof conversationControllerRemove>>, TError, { id: string }, TContext> => {
    const mutationOptions = getConversationControllerRemoveMutationOptions(options);

    return useMutation(mutationOptions, queryClient);
};
